COMMENT *

Лабораторная № 3
Вводится текст. Текст состоит из слов. Между словами один или несколько пробелов. 
Перед первым словом и после последнего слова могут быть пробелы. В конце текста – точка                
Требования к реализации приложения:
• Ввод данных с клавиатуры одной строкой;
• Вывод введенного текста и ответа на экран;
• Решение задачи оформить процедурой с параметрами, параметры передаются через стек;
• Использовать строковые команды с префиксом повторения.

Вариант 6
Дано предложение. 
Определить количество слов, содержащих хотя бы одну букву из двух, заданных вводом.                              
                
Данильченко Роман, 9 гр.

*

ORG 100H

.CODE
         
start:    
    ; Вывод сообщения с просьбой ввести строку
    MOV     AH, 09H
    LEA     DX, enterTextMessage
    INT     21H                                        
    
    ; Ввод строки в буфер
    MOV     AH, 0AH             
    LEA     DX, stringWithText      
    INT     21H                                          
    
    ; После ввода, длина введенной строки будет находится в [DX + 1], сама строка будет начинаться в [DX + 2]               
    MOV     SI, DX
    MOV     BL, [SI + 1] 
    MOV     textLength, BL         
                     
    ; SI + BX + 2 - адрес символа перевода каретки, на котором закончился ввод
    ; Заменяем его на доллар для вывода через прерывание 21H                 
    ADD     SI, BX
    MOV     [SI + 2], 24H       
                  
readSymbols:     
    CALL    NewLine         
         
    ; Вывод сообщения с просьбой ввести символы     
    MOV     AH, 09H
    LEA     DX, enterSymbolsMessage
    INT     21H                                                                         
               
    ; Кладём адрес строки с символами в SI
    LEA     SI, stringWithSymbols       
    
    ; Кладём кол-во вводимых символов в CX
    MOV     CX, numOfSymbols
    
readSymbol:           
    ; Считывание вводимого символа               
    CALL    ReadChar
    MOV     [SI], AL                                          
    
    ; Переходим к следующему символу
    INC     SI
    
    ; Повторяем пока не введём CX символов    
    LOOP    readSymbol
    
printString:  
    CALL    NewLine
     
    ; Вывод сообщения о введенной строке
    MOV     AH, 09H
    LEA     DX, enteredStringMessage
    INT     21H           
               
    ; Вывод введенной строки
    LEA     DX, stringWithText + 2              
    INT     21H                                                       
                            
printSymbols:               
    CALL    NewLine
    
    ; Вывод сообщения о введенных символах
    MOV     AH, 09H
    LEA     DX, enteredSymbolsMessage
    INT     21H           
    
    ; Вывод введённых символов
    LEA     DX, stringWithSymbols
    INT     21H                                      
                                
callMainProcedure: 
    ; Передача параметров в процедуру через стек  
              
    MOV     BX, numOfSymbols
    PUSH    BX          
              
    LEA     BX, stringWithSymbols
    PUSH    BX   
    
    LEA     BX, stringWithText     
    PUSH    BX                              
               
    CALL    MainProc 
    
    ; Выход из программы
    MOV     AX, 4C00H	
    INT     21H                                     
                  
                  
                                                                                                                    
MainProc PROC
    ; Добавляем BP в стек, чтобы через его адрес получить параметры процедуры из стека 
    PUSH    BP 
    MOV     BP, SP 
    
    ; Добавляем в стек значения всех регистров, которые будут использованы в процедуре        
    
    PUSH    AX        
    PUSH    BX
    PUSH    CX 
    PUSH    DX
            
    PUSH    SI
    PUSH    DI        
            
    MOV     DI, [BP + 4]        ; DI - Адрес строки-буфера
    MOV     SI, [BP + 6]        ; SI - Адрес символов
    MOV     DX, [BP + 8]        ; DX - Кол-во символов
    
    XOR     CX, CX
    MOV     CL, [DI + 1]        ; CX - Кол-во символов в строке, которые мы ещё не сравнили с 2-мя символами            
    ADD     DI, 2               ; Теперь DI - адрес первого элемента введенной строки
    
    MOV     BX, 0               ; BX - Кол-во слов, содержащих по крайней мере один из двух символов        
            
    ; Если введена только точка, то переходим к выводу ответа
    CMP     CX, 1
    JE      printAnswer
                   
compareSymbols:   
    ; Помещаем очередной символ строки в AL для сравнения с 2-мя символами 
    MOV     AL, [DI]
    
    ; Если символ оказался пробелом, переходим к пропуску пробелов
    CMP     AL, 20H
    JE      skipWhiteSpaces
    
    ; Помещаем в стек CX (кол-во символов в строке, которые мы ещё не сравнили с 2-мя символами,) и DI (адрес текущего обрабатываемого символа строки), ...           
    PUSH    CX
    PUSH    DI
    
    ; ... а на их место помещаем 2 (кол-во символов, с которыми нужно сравнить символ строки) и SI (адрес этих 2-х символов)
    MOV     CX, DX
    MOV     DI, SI
    
    ; Проходим по 2-м символам и уменьшаем CX, пока не найдем совпадающие символы или пока CX не станет 0
    REPNE   SCASB    
    JE      foundWordWithSymbol
    
    ; Если не нашли, то возвращаем прежние значения в DI и CX
    POP     DI
    POP     CX
    
    ; Переходим к следующему символу в строке
    INC     DI    
    
    ; Уменьшаем кол-во символов в строке, которые мы ещё не сравнили с 2-мя символами, и, если оно не равно 0, переходим к следующей итерации
    LOOP    compareSymbols
    JNE     printAnswer 
    
foundWordWithSymbol: 
    ; Увеличиваем счетчик слов, удовлетворяющих условию задачи
    INC     BX
    
    ; Возвращаем прежние значения в DI и CX
    POP     DI
    POP     CX
    
    ; Пропуск оставшейся части слова до первого пробела
    MOV     AL, 20H        
    REPNE   SCASB
                   
skipWhiteSpaces:                                 
    ; Пропуск всех пробелов до следующего слова или точки
    REPE    SCASB     
    
    ; Если дошли до конца строки, то переходим к печати результата
    CMP     CX, 0
    JE      printAnswer      
    
    ; Иначе возвращаемся на символ назад и увеличиваем кол-во символов в строке, которые мы ещё не сравнили с 2-мя символами      
    DEC     DI    
    INC     CX
    
    ; Переходим к следующей итерации
    JMP     compareSymbols         
        
printAnswer:
    CALL    NewLine
                  
    ; Вывод сообщения о результате
    MOV     AH, 09H
    LEA     DX, answerMessage
    INT     21H              
                  
    ; Вывод результата
    MOV     AX, BX   
    CALL    WriteInteger 
    
    ; Восстанавливаем значения использованных регистров
    
    POP     DI
    POP     SI
    
    POP     DX
    POP     CX
    POP     BX
    POP     AX     
    
    POP     BP
    
    RET                           
MainProc ENDP
               
                              
                            
; Процедура вывода десятичного числа, записанного в AX
WriteInteger PROC 
    ; Cохраняем содержимое регистров AX, BX, CX и DX, которые используются в этой процедуре, в стек  
    PUSH    AX                                          
    PUSH    BX  
    PUSH    CX  
    PUSH    DX  
    
    XOR     CX, CX                                      ; Обнуляем значение CX
    MOV     BX, 10                                      ; Помещаем число 10 в BX для целочисленного деления 
        
    TEST    AX, AX                                      ; Узнаем, отрицательное ли число, используя побитовое И   
    JS      printMinusAndMakeUnsigned                   ; Если отрицательное - выводим перед ним минус и меняем знак числа
    JMP     pushDigitsOfNumberToStackAndGetItsOrder     ; Иначе сразу переходим к получению цифр числа в стеке и его порядка

printMinusAndMakeUnsigned:
    PUSH    AX          ; Cохраняем содержимое регистра AX 
    
    MOV     DL, '-'     ; Помещаем минус в регистр DL 
    MOV     AH, 02H     ; Помещаем номер системной функции DOS 02H (вывод символа на дисплей) в регистр AH 
    INT     21h         ; Вызываем функцию
    
    POP     AX          ; Восстановление значения в регистре AX, которое было в нем до вывода минуса
    NEG     AX          ; Убираем минус у числа

; Получаем десятичные цифры, из которых состоит число (которое сейчас записано в AX), и добавляем их в стек
; В CX будет записан порядок числа (для 0..9 порядок 1, 10..99 2, ...)
pushDigitsOfNumberToStackAndGetItsOrder:  
    XOR     DX, DX                                      ; Обнуляем значение в регистре DX   
    IDIV    BX                                          ; Целочисленно делим число в AX на 10 (в BX). 
                                                        ;       Целая часть будет записана в AX,
                                                        ;       Остаток, который нам нужно добавить в стек, будет записан в DX
                              
    PUSH    DX                                          ; Добавляем очередную цифру числа в стек
    INC     CX                                          ; Увеличиваем порядок числа на единицу
    CMP     AX, 0                                       ; Узнаем, есть ли ещё в числе цифры, не добавленные в стек, путем сравнения его с нулем
    JG      pushDigitsOfNumberToStackAndGetItsOrder     ; Если число больше нуля, значит повторяем действия

; Печатаем число, доставая цифры из стека, конвертируя их в ASCII символы и выводя в консоль  
printInteger:  
    POP     AX              ; Достаём очередную цифру из стека
    ADD     AL, '0'         ; Конвертируем её в ASCII символ, добавляя '0'
  
    CALL    WriteChar       ; Вызываем процедуру вывода одного символа
    LOOP    printInteger    ; Повторяем действия в цикле до того момента, 
                            ;       пока не распечатаем все цифры числа (т.е. пока число в CX не станет равно 0),   
                            
    ; Восстановление значений в регистрах AX, BX, CX и DX, которые были в них до вывода числа                            
    POP     DX              
    POP     CX  
    POP     BX  
    POP     AX 
    RET                     ; Возвращаемся из процедуры
WriteInteger ENDP
                        
; Процедура вывода одного символа, записанного в AL                
WriteChar PROC          
    ; Cохраняем содержимое регистров AX и DX, которые используются в этой процедуре, в стек
    PUSH    AX          
    PUSH    DX  
    
    MOV     DL, AL      ; Помещаем символ, который нужно вывести, в регистр DL
    MOV     AH, 02H     ; Помещаем номер системной функции DOS 02H (вывод символа на дисплей) в регистр AH 
    INT     21h         ; Вызываем функцию
                        
    ; Восстановление значений в регистрах AX и DX, которые были в них до вывода символа                        
    POP     DX          
    POP     AX  
    
    RET                 ; Возвращаемся из процедуры
WriteChar ENDP                        
                        
; Процедура ввода символа, после процедуры введенный символ будет записан в регистр AL 
ReadChar PROC  
    MOV     AH, 01H     ; Помещаем номер системной функции DOS 01H (ввод с клавиатуры) в AH  
    INT     21H         ; Вызываем функцию
    
    RET                 ; Возвращаемся из процедуры
ReadChar ENDP    

; Переход на новую строку 
NewLine PROC  
    PUSH    AX
    PUSH    DX
    
    MOV     AH, 09H         ; Помещаем номер системной функции DOS 09H (печать строки в консоль) в AH
    LEA     DX, CRLF        ; Помещаем строку с переводом строки в DX
    INT     21H             ; Вызываем функцию
              
    POP     DX
    POP     AX
              
    RET 
NewLine ENDP          

.DATA 
    stringWithText                  DB 254, 254 DUP(?)
    stringWithSymbols               DB 2 DUP(?), '$' 
    
    numOfSymbols                    DW 2
    textLength                      DB ?
    
    enterTextMessage                DB 'Введите строку', 0DH, 0AH, 2DH, 2DH, 3EH, 20H, '$'
    enterSymbolsMessage             DB 'Введите символы', 0DH, 0AH, 2DH, 2DH, 3EH, 20H, '$'      
    
    enteredStringMessage            DB 'Введённая строка: $'
    enteredSymbolsMessage           DB 'Введённые символы: $'
    
    answerMessage                   DB 'Количество слов, содержащих хотя бы один символ из двух: $' 
    
    CRLF                            DB 0DH, 0AH, '$'    ; Перевод строки